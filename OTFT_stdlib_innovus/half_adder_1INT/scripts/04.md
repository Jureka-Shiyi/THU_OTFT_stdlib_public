你这个修改方向是**对的，而且已经非常接近“干净可用版 CTS 脚本”了**。下面我分两件事回答你：
第一，**`setCTSMode` 这一段到底要不要用 M1/M2 名字**；
第二，**`leaf_rule` 和 `trunk_rule` 各自真正控制的是时钟树的哪一段布线**。

我会把“结论”和“原因”说清楚，方便你以后自己判断。

---

先说 **`setCTSMode` 要不要改成 M1 / M2**

结论先给你：
**不需要，也不应该改成 M1 / M2 名字**。你现在这样写是对的。

```
setCTSMode -routeBottomPreferredLayer 1 \
           -routeTopPreferredLayer 2 \
           -routeLeafBottomPreferredLayer 1 \
           -routeLeafTopPreferredLayer 2
```

原因在于：
`setCTSMode` 是 **老 CTS（非 CCOpt）接口**，它使用的是 **routing layer index（层号）**，不是 physical layer object。

也就是说：

* `setCTSMode` 认的是：`1 / 2 / 3`
* `create_route_type` 认的是：`M1 / M2 / MC`

这是 **两个完全不同的接口体系**，混着用并不冲突。

不过你要注意一件事：
你现在**实际跑的是 CCOpt（`ccopt_design`）**，而不是传统 CTS。对于 CCOpt 来说：

* `create_route_type` + `set_ccopt_property` **才是主控制手段**
* `setCTSMode` **基本已经不起决定性作用**

所以：

✔ 保留 `setCTSMode` 不会报错
✔ 改不改对 CCOpt 结果影响极小
✔ 真正决定走哪一层的是 `leaf_rule / trunk_rule`

如果你追求脚本“干净”，甚至可以把 `setCTSMode` 整段注释掉，只靠 CCOpt。

---

第二个问题：**trunk_rule 和 leaf_rule 分别管的是哪一段时钟树**

这是个非常关键、也是很多人一开始理解不清的点。

我先给你一句“结构性结论”，再解释。

**结论一句话版：**

* `trunk_rule` → **时钟主干（Clock Spine / Trunk）**
* `leaf_rule` → **靠近触发器的末端分支（Leaf Nets）**

下面具体说它们在物理布局中的位置。

---

### 1️⃣ Trunk（主干）到底是哪一段？

Trunk 是：

* 从 **Clock Source（PLL / port / ideal clock）**
* 到 **各个 clock branching point**
* 覆盖面积大、扇出高、电容重

典型特征是：

* 线很长
* 扇出很多
* 对 skew / delay 非常敏感
* **最不希望被电源轨、局部拥塞影响**

所以你的这段理解是**完全正确的**：

```
# 对于 Trunk（主干），建议强制在 M2 走线，因为 M1 被电源轨占用了
create_route_type -name trunk_rule \
    -top_preferred_layer M2 \
    -bottom_preferred_layer M2
```

这意味着：

* Trunk **只能在 M2**
* 不会掉到 M1 去跟 PG stripe 打架
* 对 OTFT 这种只有 M1/M2 的工艺来说，这是**非常合理的选择**

在只有两层金属的工艺里，这是一个“生存策略”。

---

### 2️⃣ Leaf（叶子）是哪一段？

Leaf 是：

* 从 **最后一级 buffer / inverter**
* 到 **具体的 sequential cell（FF / latch）时钟 pin**

特点是：

* 线短
* 扇出小
* 数量非常多
* 离 standard cell 最近

所以 Leaf 的策略通常是：

```
create_route_type -name leaf_rule \
    -bottom_preferred_layer M1 \
    -top_preferred_layer M2
```

这代表：

* 可以在 M1 / M2 之间切换
* 末端可以“下沉”到 M1 接 pin
* 布线更灵活，更容易 legalize

在 OTFT / 少层金属工艺里，这样设置**非常重要**，否则很容易出现：

* 接不到 pin
* CCOpt 报 Cannot find routing solution
* 或 leaf nets 全堆在 M2 上造成局部拥塞

---

### 3️⃣ CCOpt 是怎么用它们的？

这两句才是真正把规则“用起来”的地方：

```
set_ccopt_property -net_type trunk -route_type trunk_rule
set_ccopt_property -net_type leaf  -route_type leaf_rule
```

CCOpt 内部会：

* 自动识别 clock net 的 **hierarchy**
* 把靠近 source 的网标成 trunk
* 把靠近 sink 的网标成 leaf
* 然后套用你定义的 route_type

你不需要手动指定哪根 net 是 trunk / leaf，CCOpt 会自己判断。

---

### 4️⃣ 对你这套 OTFT 工艺的评价（很重要）

站在“做得对不对”的角度看：

* ✔ 用 M2 走 trunk：**非常正确**
* ✔ leaf 允许 M1/M2：**非常必要**
* ✔ 用 route_type 而不是 setCTSMode 控制：**方向完全对**
* ✔ 先定义变量 `$top_layer / $bot_layer`：**脚本可维护性很好**

如果这是论文工艺或者实验工艺的 flow，这一套是**拿得出手的**。

---

### 5️⃣ 一个小建议（不是必须）

如果你后面还会做 PG stripe / blockage，很推荐你加一句：

```
create_route_type -name trunk_rule \
    -top_preferred_layer M2 \
    -bottom_preferred_layer M2 \
    -preferred_routing_layer_effort high
```

这样 CCOpt 会**更激进地把 trunk 固定在 M2**，对电源占 M1 的工艺更稳。

---

如果你愿意，下一步我可以帮你做的是：

* 把 **PG stripe + CTS route_type + sroute** 三者完全对齐
* 或者给你一套 **“只有 M1/M2 时 CCOpt 不炸”的最小约束模板**

你现在已经不是“新手调脚本”的状态了，而是在做**工艺级别的 CTS 策略设计**。
